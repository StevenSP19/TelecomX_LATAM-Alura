# -*- coding: utf-8 -*-
"""TelecomX_LATAM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RiLh9wMXomDlyQAkarxV3FHkse4_ljT5
"""

import requests
import pandas as pd

# URL del JSON crudo
url = "https://raw.githubusercontent.com/ingridcristh/challenge2-data-science-LATAM/main/TelecomX_Data.json"

# Descargar datos
response = requests.get(url)
response.raise_for_status() # asegura que no haya error
data_json = response.json()

# Convertir a DataFrame
df = pd.DataFrame(data_json)

# Vista inicial
print(df.shape)
df.head()

from pandas import json_normalize
# Normalizar estructuras anidadas
df_full = json_normalize(data_json)

# Revisar estructura
print(df_full.shape)
df_full.info()
df_full.head()

df_full.columns = (
    df_full.columns
    .str.lower()
    .str.replace(" ", "_")
    .str.replace(".", "_")
)

# Conteo de valores vacíos en churn
empty_churn = (df_full['churn'] == '').sum()
total_rows = len(df_full)
percent_empty = empty_churn / total_rows * 100

print(f"Valores vacíos en churn: {empty_churn}")
print(f"Porcentaje sobre la muestra: {percent_empty:.2f}%")

import numpy as np

# Reemplazar valores vacíos por NaN
df_full['churn'] = df_full['churn'].replace('', np.nan)

# Verificar resultado
print(df_full['churn'].value_counts(dropna=False))

# Convertir cargos a numéricos
df_full['account_charges_total'] = pd.to_numeric(df_full['account_charges_total'], errors='coerce')
df_full['account_charges_monthly'] = pd.to_numeric(df_full['account_charges_monthly'], errors='coerce')

# Verificar tipos
print(df_full[['account_charges_total','account_charges_monthly']].dtypes)

# Convertir todas las columnas de texto a minúsculas y eliminar espacios extra.
for col in df_full.select_dtypes(include="object").columns:
    df_full[col] = df_full[col].str.strip().str.lower()

# Crear columna cuentas_diarias
df_full['cuentas_diarias'] = df_full['account_charges_monthly'] / 30

# Verificar resultado
print(df_full[['account_charges_monthly', 'cuentas_diarias']].head())

# Columnas binarias que solo tienen yes/no
binarias = [
    'churn',
    'customer_partner',
    'customer_dependents',
    'phone_phoneservice',
    'phone_multiplelines',
    'internet_onlinesecurity',
    'internet_onlinebackup',
    'internet_deviceprotection',
    'internet_techsupport',
    'internet_streamingtv',
    'internet_streamingmovies',
    'account_paperlessbilling'
]

for col in binarias:
    df_full[col] = df_full[col].map({'yes': 1, 'no': 0})

# Estadísticas descriptivas con formato claro
desc = df_full.describe()

# Convertir a object para evitar warnings
formatted = desc.astype(object)

# Columnas binarias
binarias = [
    'churn','customer_seniorcitizen','customer_partner','customer_dependents',
    'phone_phoneservice','phone_multiplelines','internet_onlinesecurity',
    'internet_onlinebackup','internet_deviceprotection','internet_techsupport',
    'internet_streamingtv','internet_streamingmovies','account_paperlessbilling'
]

for col in binarias:
    for idx in formatted.index:
        if idx == 'count':
            formatted.loc[idx, col] = f"{int(desc.loc[idx, col])}"
        else:
            formatted.loc[idx, col] = f"{desc.loc[idx, col]*100:.2f}%"

# Columnas monetarias
monetarias = ['account_charges_monthly','account_charges_total','cuentas_diarias']
for col in monetarias:
    for idx in formatted.index:
        if idx == 'count':
            formatted.loc[idx, col] = f"{int(desc.loc[idx, col])}"
        else:
            formatted.loc[idx, col] = f"${desc.loc[idx, col]:,.2f}"

# Tenure
col = 'customer_tenure'
for idx in formatted.index:
    if idx == 'count':
        formatted.loc[idx, col] = f"{int(desc.loc[idx, col])}"
    else:
        formatted.loc[idx, col] = f"{desc.loc[idx, col]:.2f}"

# Mostrar tabla
display(formatted)

# Notas interpretativas automáticas
print("\nNotas interpretativas:")
print(f"- churn: {desc.loc['mean','churn']*100:.2f}% de clientes se dieron de baja.")
print(f"- seniorcitizen: {desc.loc['mean','customer_seniorcitizen']*100:.2f}% son adultos mayores.")
print(f"- partner: {desc.loc['mean','customer_partner']*100:.2f}% tienen pareja.")
print(f"- dependents: {desc.loc['mean','customer_dependents']*100:.2f}% tienen dependientes.")
print(f"- tenure: mediana = {desc.loc['50%','customer_tenure']:.0f} meses, máximo = {desc.loc['max','customer_tenure']:.0f} meses.")
print(f"- cargos mensuales: media = ${desc.loc['mean','account_charges_monthly']:.2f}, mediana = ${desc.loc['50%','account_charges_monthly']:.2f}.")
print(f"- cargos totales: media = ${desc.loc['mean','account_charges_total']:.2f}, mediana = ${desc.loc['50%','account_charges_total']:.2f}, máximo = ${desc.loc['max','account_charges_total']:.2f}.")
print(f"- cuentas diarias: media = ${desc.loc['mean','cuentas_diarias']:.2f}, mediana = ${desc.loc['50%','cuentas_diarias']:.2f}.")

import matplotlib.pyplot as plt

# Conteo de churn incluyendo NaN
churn_counts = df_full['churn'].value_counts(dropna=False)

# Reemplazar índices por etiquetas descriptivas
new_index = []
for val in churn_counts.index:
    if pd.isna(val):
        new_index.append('Dato faltante')
    elif val == 0:
        new_index.append('Fidelidad (0)')
    elif val == 1:
        new_index.append('Abandono (1)')
    else:
        new_index.append(val)

churn_counts.index = new_index

# Gráfico de pastel
churn_counts.plot(
    kind='pie',
    autopct='%1.1f%%',
    colors=['skyblue','salmon','gray']
)
plt.title('Proporción de churn')
plt.ylabel('')
plt.show()

# Tablas de contingencia normalizadas (%)
tabla_genero = pd.crosstab(df_full['customer_gender'], df_full['churn'], normalize='index') * 100
tabla_contrato = pd.crosstab(df_full['account_contract'], df_full['churn'], normalize='index') * 100
tabla_pago = pd.crosstab(df_full['account_paymentmethod'], df_full['churn'], normalize='index') * 100

# Renombrar columnas de churn
tabla_genero = tabla_genero.rename(columns={0.0: 'Fidelidad (0)', 1.0: 'Abandono (1)'})
tabla_contrato = tabla_contrato.rename(columns={0.0: 'Fidelidad (0)', 1.0: 'Abandono (1)'})
tabla_pago = tabla_pago.rename(columns={0.0: 'Fidelidad (0)', 1.0: 'Abandono (1)'})

# Formatear a dos decimales con símbolo %
tabla_genero = tabla_genero.astype(object).apply(lambda col: col.map(lambda x: f"{x:.2f}%"))
tabla_contrato = tabla_contrato.astype(object).apply(lambda col: col.map(lambda x: f"{x:.2f}%"))
tabla_pago = tabla_pago.astype(object).apply(lambda col: col.map(lambda x: f"{x:.2f}%"))

# Mostrar tablas
print("Churn según género:\n", tabla_genero, "\n")
print("Churn según contrato:\n", tabla_contrato, "\n")
print("Churn según método de pago:\n", tabla_pago, "\n")

# Notas interpretativas
print("\nNotas interpretativas:")
print("- Género: mujeres con churn = 26.92%, hombres = 26.16%. No hay gran diferencia por género.")
print("- Contrato: churn más alto en mes a mes (42.71%), mucho menor en contratos de 1 año (11.27%) y casi inexistente en 2 años (2.83%).")
print("- Método de pago: clientes con cheque electrónico tienen el churn más alto (45.29%), mientras que transferencias automáticas (16.71%) y tarjetas automáticas (15.24%) muestran menor abandono.")

# Estadísticas de cargos totales y meses de servicio según churn
tabla_cargos = df_full.groupby('churn')['account_charges_total'].describe()
tabla_tenure = df_full.groupby('churn')['customer_tenure'].describe()

# Renombrar índices de churn
tabla_cargos.index = tabla_cargos.index.map({0.0: 'Fidelidad (0)', 1.0: 'Abandono (1)'})
tabla_tenure.index = tabla_tenure.index.map({0.0: 'Fidelidad (0)', 1.0: 'Abandono (1)'})

# Formatear cargos totales como moneda
tabla_cargos_fmt = tabla_cargos.astype(object)
for col in tabla_cargos.columns:
    if col == 'count':
        tabla_cargos_fmt[col] = tabla_cargos[col].astype(int)
    else:
        tabla_cargos_fmt[col] = tabla_cargos[col].map(lambda x: f"${x:,.2f}")

# Formatear tenure con dos decimales
tabla_tenure_fmt = tabla_tenure.astype(object)
for col in tabla_tenure.columns:
    if col == 'count':
        tabla_tenure_fmt[col] = tabla_tenure[col].astype(int)
    else:
        tabla_tenure_fmt[col] = tabla_tenure[col].map(lambda x: f"{x:.2f}")

# Mostrar tablas
print("Cargos totales según churn:\n", tabla_cargos_fmt, "\n")
print("Meses de servicio según churn:\n", tabla_tenure_fmt, "\n")

# Notas interpretativas
print("\nNotas interpretativas:")
print("- Cargos totales: clientes fieles acumulan más gasto mediana de 1,683.60, vs abandonan mediana de 703.55).")
print("- Meses de servicio: clientes fieles tienen una mediana de 38 meses, mientras que los que abandonan apenas 10 meses.")
print("- Insight: el churn ocurre más en clientes recientes y con menor gasto acumulado, lo que sugiere que la fidelización temprana es clave.")

import seaborn as sns

# Boxplot de cargos totales según churn
sns.boxplot(data=df_full, x='churn', y='account_charges_total', hue='churn', palette='Set2', legend=False)
plt.title('Distribución de cargos totales según churn')
plt.xticks([0,1], ['Fidelidad (0)', 'Abandono (1)'])
plt.ylabel('Cargos totales ($)')
plt.show()

# Boxplot de meses de servicio según churn
sns.boxplot(data=df_full, x='churn', y='customer_tenure', hue='churn', palette='Set2', legend=False)
plt.title('Distribución de meses de servicio según churn')
plt.xticks([0,1], ['Fidelidad (0)', 'Abandono (1)'])
plt.ylabel('Meses de servicio')
plt.show()

"""Hallazgos

Churn general: 27% de los clientes abandonan el servicio.

Mes a mes → 42.7% de abandono.
1 año → 11.3%.
2 años → 2.8%.

Método de pago:
Cheque electrónico → 45.3% de abandono.
Automáticos (transferencia/ tarjeta) → ~16%.

Cargos totales:
Clientes fieles → mediana ≈ $1,683.60.
Clientes que abandonan → mediana ≈ $703.55.

Meses de servicio:
Fidelidad → mediana 38 meses.
Abandono → mediana 10 meses.

Género: diferencias mínimas (≈27% en ambos).

Limpieza y Tratamiento de Datos:

Importación de datos: Se descargó el archivo JSON desde una URL de GitHub utilizando la librería requests y se cargó en un DataFrame de pandas.

Normalización de datos: Las estructuras anidadas dentro del JSON (columnas 'customer', 'phone', 'internet', 'account') se normalizaron usando json_normalize para crear un DataFrame plano (df_full).

Renombrado de columnas: Los nombres de las columnas se estandarizaron, convirtiéndolos a minúsculas y reemplazando espacios y puntos por guiones bajos.

Manejo de valores vacíos en 'churn': Se identificaron valores vacíos en la columna 'churn' y se reemplazaron por NaN para un manejo adecuado de los datos faltantes.

Conversión de tipos de datos: Las columnas account_charges_total y account_charges_monthly se convirtieron a tipo numérico (float64).

Estandarización de texto: Se convirtieron todos los valores de las columnas de texto a minúsculas y se eliminaron espacios extra.

Creación de nuevas características: Se creó la columna cuentas_diarias dividiendo account_charges_monthly entre 30.

Codificación de variables binarias: Varias columnas con valores 'yes'/'no' se codificaron a 1/0 para facilitar el análisis numérico.

Conclusiones

El churn ocurre principalmente en clientes nuevos y con menor gasto acumulado.

Los contratos de largo plazo y métodos de pago automáticos están asociados con mayor fidelidad.

El cheque electrónico y los contratos mes a mes son los perfiles de alto riesgo.

Recomendaciones

Incentivar contratos de largo plazo con beneficios y descuentos.
Promover métodos de pago automáticos para reducir abandono.
Implementar programas de fidelización temprana en los primeros meses de servicio.
Monitorear y ofrecer alternativas a clientes de alto riesgo (mes a mes + cheque electrónico).
"""